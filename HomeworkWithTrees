from collections import deque


class TreeNode:
    def __init__(self, node, prev_node):
        self.node = node
        self.parent = prev_node
        self.children = []

    def add_child(self, child):
        self.children.append(child)

    def __repr__(self):
        return 'TreeNode (%s, %s)\n' % (self.node, self.children)

    def return_parent(self):
        return self.parent


def jaunt(channels, current_pos):  # TODO check edge cases, what if two channels are specified twice; what if
    jaunt_to = current_pos
    for i in channels:
        if current_pos == [i[0], i[1], i[2]]:
            print('jaunt possible#1')
            jaunt_to = [i[3], i[1], i[2]]
        elif current_pos == [i[3], i[1], i[2]]:
            print('jaunt possible#2')
            jaunt_to = [i[0], i[1], i[2]]
    return jaunt_to


# TODO: Change this whole monstrosity to a dictionary
# TODO can the world grid size be 0 0? should probable avoid a crash anyway
def next_position(world_grid, channels, current_pos, direction):
    next_point = current_pos
    if direction == 'North':
        next_point = [current_pos[0], current_pos[1], current_pos[2] + 1]
    elif direction == 'Northeast':
        next_point = [current_pos[0], current_pos[1] + 1, current_pos[2] + 1]
    elif direction == 'East':
        next_point = [current_pos[0], current_pos[1] + 1, current_pos[2]]
    elif direction == 'Southeast':
        next_point = [current_pos[0], current_pos[1] + 1, current_pos[2] - 1]
    elif direction == 'South':
        next_point = [current_pos[0], current_pos[1], current_pos[2] - 1]
    elif direction == 'Southwest':
        next_point = [current_pos[0], current_pos[1] - 1, current_pos[2] - 1]
    elif direction == 'West':
        next_point = [current_pos[0], current_pos[1] - 1, current_pos[2]]
    elif direction == 'Northwest':
        next_point = [current_pos[0], current_pos[1] - 1, current_pos[2] + 1]
    elif direction == 'Jaunt':
        next_point = jaunt(channels, current_pos)
    if next_point[1] >= len(world_grid):
        next_point = current_pos
    if next_point[2] >= len(world_grid[1]):
        next_point = current_pos
    if next_point[1] < 0:
        next_point = current_pos
    if next_point[2] < 0:
        next_point = current_pos
    return next_point


def find_path(tree, child):
    print(child)
    curr_parent = child  # tree[str(child)]
    path = list()
    while True:
        path.append(tree[str(curr_parent)])
        curr_parent = tree[str(curr_parent)]
        if curr_parent == [None]:
            break
    return path


def breadth_first(world_grid, channels, start_state, end_state):
    cost = 0
    frontier = deque([])
    node = [[int(start_state[0]), int(start_state[1]), int(start_state[2])], cost]
    tree = {str(node): [None]}

    # TODO: test path.
    if start_state == end_state:
        create_output(node)
        return
    frontier.appendleft(node)
    explored = []
    actions = ['North', 'Northeast', 'East', 'Southeast', 'South', 'Southwest', 'West', 'Northwest', 'Jaunt']
    while True:
        if len(frontier) == 0:
            no_solution = 'FAIL'
            print(no_solution)
            return create_output(no_solution)
        curr_node = frontier.pop()
        cost += 1
        explored.append(curr_node[0])
        for action in actions:
            child = [next_position(world_grid, channels, curr_node[0], action),
                     curr_node[1] + 1]
            # print('action = {}'.format(action))#Suggest: this way you can have insertions in the middle of the string
            # if not in_frontier and not in_explored:
            nodes_in_frontier = [n[0] for n in frontier]

            if child[0] not in explored and child[0] not in nodes_in_frontier:
                tree[str(child)] = curr_node
                if child[0] == end_state:
                    solution_found = 'Got something'
                    path = list()
                    path.append(child)
                    path.append(find_path(tree, child))
                    print(solution_found, child, path)
                    print(len(tree))

                    return create_output(solution_found)
                frontier.appendleft(child)


def uniform_cost(world_grid, channels, start_state, end_state, ):
    cost = 0
    node = [[int(start_state[0]), int(start_state[1]), int(start_state[2])], cost]
    tree = {str(node): [None]}
    frontier = [node]
    explored = []
    # TODO: add a path tree for the path.
    actions = ['North', 'Northeast', 'East', 'Southeast', 'South', 'Southwest', 'West', 'Northwest', 'Jaunt']
    while True:
        if len(frontier) == 0:
            no_solution = 'FAIL'
            return create_output(no_solution)
        curr_node = frontier[0]
        del frontier[0]
        if curr_node[0] == end_state:
            solution_found = 'Got something'
            path = list()
            path.append(curr_node)
            path.append(find_path(tree, curr_node))
            print(solution_found, curr_node, path)
            print(len(tree))
            return create_output(solution_found)
        explored.append(curr_node[0])
        for action in actions:
            next_node = next_position(world_grid, channels, curr_node[0], action)
            if action == 'North' or action == 'South' or action == 'East' or action == 'West':
                cost = 10
            elif action == 'Jaunt':
                cost = abs(next_node[0] - curr_node[0][0])
                if cost != 0:
                    print("{}=current node year - ".format(curr_node[0][0]), "{}=next node year".format(next_node[0]),
                          "= {} = cost".format(cost))
            else:
                cost = 14
            child = [next_node, curr_node[1] + cost]  # TODO: correct the cost for ucs
            # if not in_frontier and not in_explored:
            nodes_in_frontier = [n[0] for n in frontier]
            if child[0] not in explored and child[0] not in nodes_in_frontier:
                ind = len(frontier)
                for i in frontier:
                    if child[1] < i[1]:
                        ind = frontier.index(i)
                        break
                frontier.insert(ind, child)
                tree[str(child)] = curr_node
            elif child in nodes_in_frontier:
                index = frontier.index(child)
                if frontier > child[1]:
                    frontier.insert(index, child)
                    tree[str(child)] = curr_node


def a_star(world_grid, channels, start_state, end_state):
    return


def create_output(out_list):
    file_output = open('output.txt', 'w')
    file_output.write("You know how it goes. Slow learning" + '\n')
    file_output.write(str(out_list))
    file_output.close()


file_Input = open("input.txt")
lines = file_Input.readlines()
file_Input.close()

algorithm = lines[0].strip()
grid = lines[1].split()
width = int(grid[0])
height = int(grid[1])
# create world
world = [[j for j in range(height)] for i in range(width)]

start = lines[2].rstrip().split()
start = [int(i) for i in start]

end = lines[3].rstrip().split()
end = [int(i) for i in end]

no_channels = int(lines[4].rstrip())

i = 0
ch = list()

while i < no_channels:
    single_channel = lines[5 + i].split()
    single_channel = [int(i) for i in single_channel]
    ch.append(single_channel)
    i = i + 1

if algorithm == "BFS":
    breadth_first(world, ch, start, end)
elif algorithm == "UCS":
    uniform_cost(world, ch, start, end)
elif algorithm == "A*":
    a_star(world, ch, start, end)
